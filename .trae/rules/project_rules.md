# Python通用工具库项目规则

## 项目概述

本项目是一个Python通用方法库(pyutils)，旨在提供常用的Python工具函数和实用程序。

## 代码风格规范

### Python代码规范

- **严格遵循PEP 8**：使用4个空格缩进，行长度限制为88字符
- **类型注解**：所有公共函数和方法必须包含完整的类型注解
- **文档字符串**：所有公共函数、类和模块必须有详细的docstring
- **命名规范**：
  - 函数和变量使用snake_case
  - 类名使用PascalCase
  - 常量使用UPPER_CASE
  - 私有成员以单下划线开头

### 代码质量工具

- **Ruff**：用于代码格式化和静态检查
- **MyPy**：严格的类型检查，启用strict模式
- **测试覆盖率**：要求≥90%的代码覆盖率

## 项目结构规范

### 目录组织

```
src/pyutils/          # 主要源代码
tests/               # 测试代码
docs/                # 文档
```

### 文件组织原则

- 所有源代码放在`src/pyutils/`目录下
- 测试文件以`test_`前缀命名，放在`tests/`目录
- 每个模块都应有对应的测试文件
- 公共API通过`__init__.py`暴露

## 开发流程规范

### 依赖管理

- 使用`pyproject.toml`管理项目配置和依赖
- 核心依赖：`typer`（CLI工具）
- 开发依赖：`pytest`, `mypy`, `ruff`, `coverage`

### 测试要求

- **测试框架**：使用pytest
- **测试覆盖率**：核心功能必须≥90%覆盖率
- **测试命名**：测试函数以`test_`开头，清晰描述测试场景
- **测试独立性**：每个测试用例必须独立运行
- **异常测试**：必须测试边界条件和异常情况

### 版本兼容性

- **Python版本**：支持Python 3.6+（根据.travis.yml配置）
- **向后兼容**：新功能不能破坏现有API
- **弃用策略**：废弃功能需要提前一个版本警告

## 文档规范

### 文档要求

- 使用**Sphinx**生成文档
- **README.rst**：项目介绍、安装和基本使用
- **API文档**：所有公共接口必须有详细文档
- **使用示例**：提供清晰的代码示例

### 文档格式

- 使用reStructuredText格式
- 代码示例必须可执行
- 包含安装、使用、贡献指南

## 发布和部署

### 版本管理

- 遵循**语义化版本**规范(SemVer)
- 版本号格式：MAJOR.MINOR.PATCH
- 在`__init__.py`和`pyproject.toml`中保持版本一致

### CI/CD流程

- 使用github actions
- 自动运行测试套件
- 检查代码质量和覆盖率
- 支持多Python版本测试

## 贡献规范

### 代码提交

- **提交信息**：使用清晰的提交信息，遵循约定式提交
- **分支策略**：功能开发使用feature分支
- **代码审查**：所有代码变更必须经过审查

### 新功能开发

- 新需求开发在dev分支（从main拉取），或者从main拉取feature分支开发
- 先编写测试用例（TDD）
- 确保所有测试通过
- 更新相关文档
- 添加使用示例

## 性能和安全

### 性能要求

- 优先使用Python内置函数和标准库
- 避免不必要的依赖
- 考虑内存使用效率
- 提供性能基准测试

### 安全考虑

- 输入验证和边界检查
- 避免使用不安全的函数
- 定期更新依赖版本
- 不在代码中硬编码敏感信息

## 工具配置

### 编辑器配置

- 遵循`.editorconfig`设置
- 使用UTF-8编码
- Unix风格换行符(LF)
- 文件末尾插入换行符

### 开发环境

- 推荐使用虚拟环境
- 安装开发依赖：`pip install -e .[dev]`
- 运行测试：`pytest`
- 代码检查：`ruff check .`
- 类型检查：`mypy .`

## AI助手行为规范

### 代码生成要求

- 生成的代码必须符合项目的所有规范
- 包含完整的类型注解和文档字符串
- 提供对应的测试用例
- 考虑错误处理和边界情况

### 建议和优化

- 优先推荐标准库解决方案
- 关注代码的可读性和维护性
- 提供性能优化建议
- 确保向后兼容性

### 问题解决

- 提供具体可执行的解决方案
- 解释技术选择的原因
- 考虑多种实现方案的权衡
- 关注长期维护性
